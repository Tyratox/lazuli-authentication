<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: user.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: user.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const async = require("async");
const path = require("path");
const Sequelize = require("sequelize");

const {
	LOCALES,
	TOKEN_LENGTH,
	RESET_CODE_LIFETIME,
	CONFIRM_TOKEN_LENGTH
} = require("lazuli-require")("lazuli-config");

const eventEmitter = require("lazuli-require")("lazuli-core/event-emitter");
const valueFilter = require("lazuli-require")("lazuli-core/value-filter");
const sequelize = require("lazuli-require")("lazuli-core/sequelize");

const {
	generateRandomString,
	generateHash
} = require("../utilities/crypto.js");

const Permission = require("./permission");

/**
 * This is the authentication class which handles the registration and, of
 * course, the authentication of users
 */
class Ble {
	constructor() {
		valueFilter.add("sequelize.models", this.registerModels.bind(this));
		valueFilter.add(
			"graphql.schema.root.query.fields",
			this.addGraphQlQueryFields.bind(this)
		);
		valueFilter.add(
			"graphql.schema.root.mutation.fields",
			this.addGraphQlMutationFields.bind(this)
		);
	}
}

/**
 * @type {User}
 * @class
 * @version 1.0
 * @since 1.0
 */
const User = sequelize.define("user", {
	nameDisplay: {
		type: Sequelize.STRING,
		default: ""
	},
	nameFirst: {
		type: Sequelize.STRING,
		default: ""
	},
	nameLast: {
		type: Sequelize.STRING,
		default: ""
	},
	emailVerified: {
		type: Sequelize.STRING,
		unique: true
	},
	emailUnverified: {
		type: Sequelize.STRING,
		unique: true
	},
	emailVerificationCode: {
		type: Sequelize.STRING
	},
	passwordHash: {
		type: Sequelize.STRING
	},
	passwordSalt: {
		type: Sequelize.STRING
	},
	passwordAlgorithm: {
		type: Sequelize.STRING
	},
	passwordResetCode: {
		type: Sequelize.STRING
	},
	passwordResetCodeExpirationDate: {
		type: Sequelize.DATE
	},
	locale: {
		type: Sequelize.STRING,
		default: "en-us",
		validate: {
			isIn: [LOCALES]
		}
	}
});

/**
 * Associates this model with others
 * @memberof User
 * @public
 * @version 1.0
 * @since 1.0
 * 
 * @fires authentication.model.user.association
 * 
 * @param {object} models The models to associate with
 * @param {object} models.Permission The permission model
 * @param {object} models.OauthProvider The oauth provider model
 * @param {object} models.OauthAccessToken The oauth access token model
 * @param {object} models.OauthCode The oauth code model
 * @param {object} models.OauthClient The oauth client model
 * @return {promise}
 */
User.associate = function({
	Permission,
	OauthProvider,
	OauthAccessToken,
	OauthCode,
	OauthClient
}) {
	/**
	 * The User - Permission relation
	 * @type {Object}
	 * @public
	 * @since 1.0
	 * @memberof User
	 */
	this.Permissions = this.belongsToMany(Permission, {
		as: "Permissions",
		foreignKey: "userId",
		otherKey: "permissionId",
		through: "permission_relations",
		onDelete: "cascade",
		hooks: true
	});

	/**
	 * The User - OauthProvider relation
	 * @type {Object}
	 * @public
	 * @since 1.0
	 * @memberof User
	 */
	this.OauthProviders = this.hasMany(OauthProvider, {
		as: "OauthProviders",
		foreignKey: "userId",
		onDelete: "cascade",
		hooks: true
	});

	/**
	 * The User - OauthAccessToken relation
	 * @type {Object}
	 * @public
	 * @since 1.0
	 * @memberof User
	 */
	this.OauthAccessTokens = this.hasMany(OauthAccessToken, {
		as: "OauthAccessTokens",
		foreignKey: "userId",
		onDelete: "cascade",
		hooks: true
	});

	/**
	 * The User - OauthCode relation
	 * @type {Object}
	 * @public
	 * @since 1.0
	 * @memberof User
	 */
	this.OauthCodes = this.hasMany(OauthCode, {
		as: "OauthCodes",
		foreignKey: "userId",
		onDelete: "cascade",
		hooks: true
	});

	/**
	 * The User - OauthClient relation
	 * @type {Object}
	 * @public
	 * @since 1.0
	 * @memberof User
	 */
	this.OauthClients = this.hasMany(OauthClient, {
		as: "OauthClients",
		foreignKey: "userId",
		onDelete: "cascade",
		hooks: true
	});

	/**
	 * The related graphql type
	 * @type {Object}
	 * @public
	 * @since 1.0
	 * @memberof User
	 */
	this.graphQlType = require("../types/user");

	/**
     * Event that is fired before the password reset code and
	 * its expiration date are set during a password reset.
	 * This event can (and should) be used to hand the reset code
	 * the the user via e.g. email.
     *
     * @event authentication.model.user.association
	 * @version 1.0
	 * @since 1.0
     * @type {object}
     * @property {object} User The user model
     */
	return eventEmitter.emit("authentication.model.user.association", {
		User: this
	});
};

/**
 * Gets the sequelize user a passport profile
 * @memberof User
 * @public
 * @version 1.0
 * @since 1.0
 * 
 * @param  {object} profile The passport profile of the user to search for
 * @return {promise&lt;User>} A sequelize search promise
 */
User.getUserByPassportProfile = function(profile) {
	return this.findOne({
		where: {
			emailVerified: { $in: profile.emails.map(obj => obj.value) }
		}
	});
};

/**
 * Registers a user
 * @memberof User
 * @public
 * @version 1.0
 * @since 1.0
 * 
 * @param  {string} firstName The user's first name
 * @param  {string} email The user's email address
 * @param  {string} locale The user's locale
 * @return {promise&lt;User>} A promise to check whether the registration was successfull
 */
User.register = function(firstName, email, locale) {
	let lastName = "";
	const names = firstName.split(" ");

	if (names.length === 2) {
		firstName = names[0];
		lastName = names[1];
	}

	const userData = {
		nameDisplay: firstName,
		nameFirst: firstName,

		permission: [],

		emailUnverified: email,
		emailVerificationCode: "",

		locale: locale
	};

	return this.findAll({
		where: {
			$or: [{ emailVerified: email }, { emailUnverified: email }]
		}
	}).then(users => {
		if (users &amp;&amp; users.length > 0) {
			return Promise.reject("This email is already registered!");
		} else {
			return this.create(userData).then(user => {
				return user.initEmailVerification(true).then(() => {
					return Promise.resolve(user);
				});
			});
		}
	});
};

/**
 * Finds or creates a user based on a passport profile
 * @memberof User
 * @public
 * @version 1.0
 * @since 1.0
 * 
 * @fires authentication.model.user.from-passport-profile.before
 * @fires authentication.model.user.from-passport-profile.after
 * 
 * @param  {object} profile The passport profile to base to user on
 * @return {promise&lt;User>} The promise to check for the success of the action
 */
User.findOrCreateUserByPassportProfile = function(profile) {
	return this.getUserByPassportProfile(profile).then(user => {
		if (user) {
			//update values for the current user
			return user._updateFromPassportProfile(profile);
		} else {
			//we have to create a new user
			return this._createFromPassportProfile(profile);
		}
	});
};

/**
 * Creates a user based on a passport profile
 * @memberof User.prototype
 * @private
 * @version 1.0
 * @since 1.0
 * 
 * @fires authentication.model.user.from-passport-profile.before
 * @fires authentication.model.user.from-passport-profile.after
 * 
 * @param  {object} profile The passport profile to base the user on
 * @return {promise&lt;User>} A promise to check for the success of the action
 */
User._createFromPassportProfile = function(profile) {
	const user = this.build({
		nameDisplay: profile.displayName,
		nameFirst: profile.givenName,
		nameLast: profile.familyName,

		emailVerified: profile.emails[0].value
	});

	/**
     * Event that is fired before the user is created
	 * based on a passport profile.
	 * This event can be used to add e.g. a profile picutre
     *
     * @event authentication.model.user.from-passport-profile.before
     * @type {object}
     * @property {object} user The user model
	 * @property {object} profile The passport profile
     */
	eventEmitter
		.emit("authentication.model.user.from-passport-profile.before", {
			user,
			profile
		})
		.then(user.save)
		.then(user.reload)
		.then(() =>
			/**
			 * Event that is fired after the user is created
			 * based on a passport profile.
			 *
			 * @event authentication.model.user.from-passport-profile.after
			 * @type {object}
			 * @property {object} user The user model
			 * @property {object} profile The passport profile
			 */
			eventEmitter.emit("model.user.from-passport-profile.after", {
				user,
				profile
			})
		)
		.then(() => Promise.resolve(user));
	user;
};

/**
 * Updates a user based on a passport profile
 * @memberof User.prototype
 * @private
 * @version 1.0
 * @since 1.0
 * 
 * @fires authentication.model.user.from-passport-profile.before
 * @fires authentication.model.user.from-passport-profile.after
 * 
 * @param  {object} profile The passport profile to base the user on
 * @return {promise&lt;User>} A promise to check for the success of the action
 */
User.prototype._updateFromPassportProfile = function(profile) {
	this.set({
		nameDisplay: profile.displayName,
		nameFirst: profile.givenName,
		nameLast: profile.familyName
	});

	/**
     * Event that is fired before the user is updated
	 * based on a passport profile.
	 * This event can be used to add e.g. a profile picutre
     *
     * @event authentication.model.user.from-passport-profile.before
     * @type {object}
     * @property {object} user The user model
	 * @property {object} profile The passport profile
     */
	eventEmitter
		.emit("authentication.model.user.from-passport-profile.before", {
			user: this,
			profile
		})
		.then(this.save)
		.then(this.reload)
		.then(() =>
			/**
			 * Event that is fired after the user is updated
			 * based on a passport profile.
			 *
			 * @event authentication.model.user.from-passport-profile.after
			 * @type {object}
			 * @property {object} user The user model
			 * @property {object} profile The passport profile
			 */
			eventEmitter.emit("model.user.from-passport-profile.after", {
				user,
				profile
			})
		)
		.then(() => Promise.resolve(this));
};

/**
 * Verifies if the passed password is equal to the stored one
 * @memberof User.prototype
 * @public
 * @version 1.0
 * @since 1.0
 * 
 * @param  {string} password The password to verify
 * @return {promise&lt;boolean>} A promise to check whether the password could be verified
 */
User.prototype.verifyPassword = function(password) {
	const { hash } = generateHash(
		password,
		this.get("passwordSalt"),
		this.get("passwordAlgorithm")
	);

	const { hash: newHash, newAlgorithm } = generateHash(
		password,
		this.get("passwordSalt")
	);

	if (hash == this.get("passwordHash")) {
		//password is correct, check if the hash algorithm changed

		if (this.get("passwordAlgorithm") !== newAlgorithm) {
			//yes it did, hash and store the password with the new algorithm one
			this.set("passwordHash", newHash);
			this.set("passwordAlgorithm", newAlgorithm);
		}

		return this.save().then(() => {
			return Promise.resolve(true);
		});
	} else {
		return Promise.resolve(false);
	}
};

/**
 * Updates the user's password
 * @memberof User.prototype
 * @public
 * @version 1.0
 * @since 1.0
 * 
 * @param  {string} password The new password
 * @param  {string} passwordResetCode The received password reset code
 * @return {promise&lt;void>} A promise to check whether the password could be updated
 */
User.prototype.updatePassword = function(password, passwordResetCode) {
	if (
		this.get("passwordResetCode") &amp;&amp;
		this.get("passwordResetCode") === passwordResetCode
	) {
		if (this.get("passwordResetCodeExpirationDate") >= new Date()) {
			const { hash, salt, algorithm } = generateHash(password);

			this.set({
				passwordHash: hash,
				passwordSalt: salt,
				passwordAlgorithm: algorithm,
				passwordResetCode: ""
			});

			return this.save();
		} else {
			return Promise.reject(
				new Error("The password reset code has already expired!")
			);
		}
	} else {
		return Promise.reject(new Error("The password reset code is invalid!"));
	}
};

/**
 * Initiates a passowrd reset
 * @memberof User.prototype
 * @public
 * @version 1.0
 * @since 1.0
 * 
 * @fires authentication.model.user.password-reset.init
 * 
 * @return {promise&lt;void>} A promise to check whether the email was sent
 */
User.prototype.initPasswordReset = function() {
	const passwordResetCode = generateRandomString(TOKEN_LENGTH);
	const expirationDate = Date.now() + RESET_CODE_LIFETIME * 1000;

	/**
     * Event that is fired before the password reset code and
	 * its expiration date are set during a password reset.
	 * This event can (and should) be used to hand the reset code
	 * the the user via e.g. email.
     *
     * @event authentication.model.user.password-reset
     * @type {object}
     * @property {string} passwordResetCode The password reset code
	 * @property {number} expirationDate The passwort reset code expiration date
     */
	return eventEmitter
		.emit("authentication.model.user.password-reset", {
			passwordResetCode,
			expirationDate
		})
		.then(() => {
			this.set("passwordResetCode", passwordResetCode);
			this.set("passwordResetCodeExpirationDate", expirationDate);

			return this.save();
		});
};

/**
 * Initiates the email verification
 * @memberof User.prototype
 * @public
 * @version 1.0
 * @since 1.0
 * 
 * @fires authentication.model.user.email-verification
 * 
 * @param {boolean} [registration=false] Whether this is the initial email verification (registration)
 * @return {promise&lt;void>} A promise to check whether the email was sent
 */
User.prototype.initEmailVerification = function(registration = false) {
	const emailVerificationCode = generateRandomString(CONFIRM_TOKEN_LENGTH);

	/**
     * Event that is fired before the email verification code is 
	 * set during the email verification.
	 * This event can (and should) be used to hand the verification code
	 * the the user via email.
     *
     * @event authentication.model.user.email-verification
     * @type {object}
     * @property {string} emailVerificationCode The email verification code
	 * @property {boolean} registration Whether this is the initial email verification (registration)
     */
	return eventEmitter
		.emit("authentication.model.user.email-verification", {
			emailVerificationCode,
			registration
		})
		.then(() => {
			this.set("emailVerificationCode", emailVerificationCode);

			if (registration) {
				this.set("passwordResetCode", emailVerificationCode);
				this.set(
					"passwordResetCodeExpirationDate",
					Date.now() + RESET_CODE_LIFETIME * 1000
				);
			}

			return this.save();
		});
};

/**
 * Verifies an email
 * @memberof User.prototype
 * @public
 * @version 1.0
 * @since 1.0
 * 
 * @param  {string} [email=""] The email to verify
 * @param  {string} [emailVerificationCode=null] The received email verification code
 * @return {promise&lt;void>} A promise to check whether the email could be verified
 */
User.prototype.verifyEmail = function(
	email = "",
	emailVerificationCode = null
) {
	if (
		email &amp;&amp;
		emailVerificationCode &amp;&amp;
		this.get("emailVerificationCode") === emailVerificationCode &amp;&amp;
		this.get("emailUnverified") === email
	) {
		this.set({
			emailVerified: email,
			emailVerificationCode: "",
			emailUnverified: null
		});

		return this.save();
	} else {
		return Promise.reject(new Error("The email verification code is invalid!"));
	}
};

/**
 * Checks whether the user has all of the passed permissions
 * @memberof User.prototype
 * @public
 * @version 1.0
 * @since 1.0
 * 
 * @param  {array}  [permissionsNeeded=[]] The permissions to check for
 * @return {promise&lt;boolean>} Whether the user has the given permissions
 */
User.prototype.doesHavePermissions = function(permissionsNeeded = []) {
	let promise;

	if (!this.get("Permissions")) {
		promise = this.reload({
			include: [
				{
					model: Permission,
					as: "Permissions"
				}
			]
		});
	} else {
		promise = Promise.resolve(this);
	}

	return promise.then(() => {
		const permissions = this.get("Permissions").map(permission =>
			permission.get("permission")
		);

		const missing = permissionsNeeded.filter(permission => {
			for (let i = 0; i &lt; permissions.length; i++) {
				// has exactly this permission or has a higher level permission

				if (
					permission === permissions[i] ||
					permission.startsWith(permissions[i] + ".")
				) {
					return false; //not missing, remove from array
				}
			}

			return true; //missing, leave in array
		});

		return Promise.resolve(missing.length === 0);
	});
};

/**
 * Checks whether the user has the passed permission
 * @memberof User.prototype
 * @public
 * @version 1.0
 * @since 1.0
 * 
 * @param  {array}  [permissionsNeeded=[]] The permission to check for
 * @return {promise&lt;boolean>} Whether the user has the given permissions
 */
User.prototype.doesHavePermission = function(permission) {
	return this.doesHavePermissions([permission]);
};

/**
 * Sets the permissions of the user
 * @memberof User.prototype
 * @public
 * @version 1.0
 * @since 1.0
 * 
 * @param  {array} [permissions=[]] An array of permissions to set to the user
 * @return {promise&lt;boolean>} A promise whether the update was successfull
 */
User.prototype.setPermissionArray = function(permissions = []) {
	return new Promise((resolve, reject) => {
		let permissionInstances = [];

		async.each(
			permissions,
			(permission, callback) => {
				Permission.findOrCreate({
					where: { permission },
					defaults: { permission }
				})
					.then(result => {
						const permissionInstance = result[0],
							created = result[1];

						permissionInstances.push(permissionInstance);
						callback();
					})
					.catch(callback);
			},
			err => {
				if (err) {
					reject(err);
				}

				this.setPermissions(permissionInstances)
					.then(() => resolve(true))
					.catch(reject);
			}
		);
	});
};

module.exports = User;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Ble.html">Ble</a></li><li><a href="User.html">User</a></li></ul><h3>Events</h3><ul><li><a href="authentication.model.user.html#.event:association">association</a></li><li><a href="authentication.model.user.html#.event:email-verification">email-verification</a></li><li><a href="authentication.model.user.html#.event:password-reset">password-reset</a></li><li><a href="authentication.model.user.from-passport-profile.html#.event:after">after</a></li><li><a href="authentication.model.user.from-passport-profile.html#.event:before">before</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Oct 25 2017 22:19:06 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
